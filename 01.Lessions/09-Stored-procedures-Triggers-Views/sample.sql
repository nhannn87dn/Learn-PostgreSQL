create [or replace] procedure procedure_name(parameter_list)
language plpgsql
as $$
declare
-- variable declaration
begin
-- stored procedure body
end; $$


return;

drop table if exists accounts;

create table accounts (
    id int generated by default as identity,
    name varchar(100) not null,
    balance dec(15,2) not null,
    primary key(id)
);

insert into accounts(name,balance)
values('Bob',10000);

insert into accounts(name,balance)
values('Alice',10000);

create or replace procedure transfer(
   sender int,
   receiver int, 
   amount numeric
)
language plpgsql    
as $$
begin
    -- Trừ tiền của người gửi 
    update accounts 
    set balance = balance - amount 
    where id = sender;
    -- Cộng tiền cho người nhận
    update accounts 
    set balance = balance + amount 
    where id = receiver;

    commit; --xác nhận hoàn tất transaction
end;$$


call transfer(1,2,1000);

--Xóa một theo tên
drop procedure insert_actor;
--Xóa nhiều theo tên
drop procedure 
	delete_actor, 
	update_actor;
--Xóa theo tên và kiểu dữ liệu của tham số
drop procedure insert_actor(varchar,varchar);


CREATE FUNCTION trigger_function() 
   RETURNS TRIGGER 
   LANGUAGE PLPGSQL
AS $$
BEGIN
   -- trigger logic
END;
$$

CREATE TRIGGER trigger_name 
   {BEFORE | AFTER} { event } 
   ON table_name
   [FOR [EACH] { ROW | STATEMENT }]
       EXECUTE PROCEDURE trigger_function


CREATE OR REPLACE FUNCTION uft_update_product_stock()
RETURNS TRIGGER AS $$
BEGIN
    -- Cập nhật số lượng trong bảng stocks
    UPDATE stocks
    SET quantity = s.quantity - NEW.quantity
    FROM stocks AS s
    INNER JOIN orders AS o ON o.order_id = NEW.order_id 
        AND o.store_id = s.store_id
    WHERE s.product_id = NEW.product_id;
    
    RETURN NEW; -- Trả về bản ghi mới đã được chèn
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_items_update_stock
AFTER INSERT ON order_items
FOR EACH ROW
EXECUTE FUNCTION uft_update_product_stock();



CREATE OR REPLACE view_name 
AS 
query


CREATE VIEW v_daily_sales --đặt tên với prefix v_
AS
SELECT
    EXTRACT(YEAR FROM order_date) AS y,
    EXTRACT(MONTH FROM order_date) AS m,
    EXTRACT(DAY FROM order_date) AS d,
    p.product_id,
    product_name,
    quantity * i.price AS sales
FROM
    orders AS o
INNER JOIN order_items AS i
    ON o.order_id = i.order_id
INNER JOIN products AS p
    ON p.product_id = i.product_id;


SELECT * FROM v_daily_sales;



ALTER VIEW v_daily_sales RENAME TO v_daily_sales_new;

DROP VIEW [ IF EXISTS ] view_name;

DROP VIEW [IF EXISTS] view_name
[CASCADE | RESTRICT]



CREATE MATERIALIZED VIEW view_name
AS
query
WITH [NO] DATA;


REFRESH MATERIALIZED VIEW [CONCURRENTLY] view_name;

DROP MATERIALIZED VIEW view_name;

CREATE VIEW v_storesByPhone --đặt tên với prefix v_
AS
SELECT * FROM stores
WHERE phone IS NULL --Nếu WHERE không thõa mãn--> View bị Lỗi
WITH CHECK OPTION;

UPDATE v_storesByPhone SET phone = 'test' 
WHERE  store_id = 3;



--View A
CREATE VIEW v_storesNull --đặt tên với prefix v_
AS
-- Lấy dữ liệu từ View B
SELECT * FROM v_storesByPhone
WITH CHECK OPTION;


--View B
CREATE VIEW v_storesByPhone --đặt tên với prefix v_
AS
SELECT * FROM stores
WHERE phone IS NULL --Nếu WHERE không thõa mãn--> View bị Lỗi
WITH CHECK OPTION;



