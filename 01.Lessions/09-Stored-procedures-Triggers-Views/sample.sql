create [or replace] procedure procedure_name(parameter_list)
language plpgsql
as $$
declare
-- variable declaration
begin
-- stored procedure body
end; $$


return;

drop table if exists accounts;

create table accounts (
    id int generated by default as identity,
    name varchar(100) not null,
    balance dec(15,2) not null,
    primary key(id)
);

insert into accounts(name,balance)
values('Bob',10000);

insert into accounts(name,balance)
values('Alice',10000);

create or replace procedure transfer(
   sender int,
   receiver int, 
   amount numeric
)
language plpgsql    
as $$
begin
    -- Trừ tiền của người gửi 
    update accounts 
    set balance = balance - amount 
    where id = sender;
    -- Cộng tiền cho người nhận
    update accounts 
    set balance = balance + amount 
    where id = receiver;

    commit; --xác nhận hoàn tất transaction
end;$$


call transfer(1,2,1000);

--Xóa một theo tên
drop procedure insert_actor;
--Xóa nhiều theo tên
drop procedure 
	delete_actor, 
	update_actor;
--Xóa theo tên và kiểu dữ liệu của tham số
drop procedure insert_actor(varchar,varchar);


CREATE FUNCTION trigger_function() 
   RETURNS TRIGGER 
   LANGUAGE PLPGSQL
AS $$
BEGIN
   -- trigger logic
END;
$$

CREATE TRIGGER trigger_name 
   {BEFORE | AFTER} { event } 
   ON table_name
   [FOR [EACH] { ROW | STATEMENT }]
       EXECUTE PROCEDURE trigger_function


CREATE OR REPLACE FUNCTION uft_update_product_stock()
RETURNS TRIGGER AS $$
BEGIN
    -- Cập nhật số lượng trong bảng stocks
    UPDATE stocks
    SET quantity = s.quantity - NEW.quantity
    FROM stocks AS s
    INNER JOIN orders AS o ON o.order_id = NEW.order_id 
        AND o.store_id = s.store_id
    WHERE s.product_id = NEW.product_id;
    
    RETURN NEW; -- Trả về bản ghi mới đã được chèn
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_items_update_stock
AFTER INSERT ON order_items
FOR EACH ROW
EXECUTE FUNCTION uft_update_product_stock();



CREATE OR REPLACE view_name 
AS 
query


CREATE VIEW v_daily_sales --đặt tên với prefix v_
AS
SELECT
    EXTRACT(YEAR FROM order_date) AS y,
    EXTRACT(MONTH FROM order_date) AS m,
    EXTRACT(DAY FROM order_date) AS d,
    p.product_id,
    product_name,
    quantity * i.price AS sales
FROM
    orders AS o
INNER JOIN order_items AS i
    ON o.order_id = i.order_id
INNER JOIN products AS p
    ON p.product_id = i.product_id;


SELECT * FROM v_daily_sales;



ALTER VIEW v_daily_sales RENAME TO v_daily_sales_new;

DROP VIEW [ IF EXISTS ] view_name;

DROP VIEW [IF EXISTS] view_name
[CASCADE | RESTRICT]



CREATE MATERIALIZED VIEW view_name
AS
query
WITH [NO] DATA;


REFRESH MATERIALIZED VIEW [CONCURRENTLY] view_name;

DROP MATERIALIZED VIEW view_name;





CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50),
  department_id INT
);

-- Chèn dữ liệu vào bảng employees
INSERT INTO employees (name, department_id) VALUES ('Alice', 1);
INSERT INTO employees (name, department_id) VALUES ('Bob', 2);
INSERT INTO employees (name, department_id) VALUES (NULL, 2);

-- Tạo View a, lấy tên là NULL, không có CHECK OPTION
CREATE OR REPLACE VIEW view_A AS
SELECT *
FROM employees
WHERE name IS NULL;
-- Hiển thị dữ liệu từ view_A
SELECT * FROM view_A;
--Cập nhật Dữ liệu từ View A ==> Cập nhật OK
UPDATE view_A SET name = 'Adrew' WHERE department_id = 2;

-- Tạo lại giá trị NULL để demo View B
UPDATE employees SET name = NULL WHERE id = 3;
-- Tạo view B với WITH CASCADED CHECK OPTION
CREATE OR REPLACE VIEW view_B AS
SELECT * FROM view_A WHERE department_id = 2
WITH CASCADED CHECK OPTION;
-- Hiển thị dữ liệu từ view_B
SELECT * FROM view_B;
--Cập nhật Dữ liệu từ View B ==> Lỗi
UPDATE view_B  SET name = 'Adrew' WHERE id = 3;


CREATE OR REPLACE VIEW view_B AS
SELECT * FROM view_A WHERE department_id = 2
WITH LOCAL CHECK OPTION;


